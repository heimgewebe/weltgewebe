#!/usr/bin/env bash
set -euo pipefail

# -----------------------------
# Weltgewebe Drift-to-PR Tool
# -----------------------------
# Safely stages local changes (drift) and creates a PR.
#
# Usage:
#   weltgewebe-pr [--plan] [--draft] [--no-pr] [--no-push] [--title "..."]

REPO_DIR="${REPO_DIR:-$(pwd)}"

# Flags
MODE="apply"      # apply (default) or plan
CREATE_PR=1
PUSH=1
DRAFT_PR=0
PR_TITLE=""
BASE_BRANCH=""
REMOTE="origin"
INCLUDE_ARTIFACTS=0
CUSTOM_ALLOW=""

# Default Allowlist (strict prefix-based)
ALLOWLIST_DEFAULT="docs/ scripts/ infra/ configs/ .github/"

usage() {
  echo "Usage: $0 [--plan] [--draft] [--no-pr] [--no-push] [--title \"...\"] [--allow \"...\"]"
  echo
  echo "  --plan             Dry-run: show what would happen (no changes)"
  echo "  --draft            Create PR as draft"
  echo "  --no-pr            Skip PR creation (only branch/commit/push)"
  echo "  --no-push          Skip push (only local branch/commit)"
  echo "  --title \"...\"      PR title (default: ops(heimserver): sync local drift)"
  echo "  --base branch      Base branch (default: auto-detect)"
  echo "  --allow \"path...\"  Override allowlist (dangerous, space-separated)"
  echo "  --include-artifacts Allow staging artifacts/ folder"
  echo
  echo "Default behavior: Creates branch, commits allowed drift, pushes, and opens a PR."
  exit 1
}

while [[ "$#" -gt 0 ]]; do
  case $1 in
    --plan) MODE="plan" ;;
    --draft) DRAFT_PR=1 ;;
    --no-pr) CREATE_PR=0 ;;
    --no-push) PUSH=0; CREATE_PR=0 ;; # Implicitly no PR if no push
    --title) PR_TITLE="$2"; shift ;;
    --base) BASE_BRANCH="$2"; shift ;;
    --remote) REMOTE="$2"; shift ;;
    --allow) CUSTOM_ALLOW="$2"; shift ;;
    --include-artifacts) INCLUDE_ARTIFACTS=1 ;;
    -h|--help) usage ;;
    *) echo "Unknown parameter: $1"; usage ;;
  esac
  shift
done

cd "$REPO_DIR"

# Cleanup function (trap)
cleanup() {
    # NO EXIT HERE - just cleanup
    # Cleanup temp file
    if [[ -n "${BODY_TEMP:-}" ]] && [[ -f "$BODY_TEMP" ]]; then
        rm -f "$BODY_TEMP" 2>/dev/null || true
    fi

    # Only attempt to restore branch if we switched (check HEAD)
    local current_head
    current_head="$(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo "detached")"

    if [[ -n "${ORIG_REF:-}" ]] && [[ "$current_head" != "$ORIG_REF" ]]; then
        if git checkout -q "$ORIG_REF" 2>/dev/null; then
             # Silent return or minimal logging
             :
        else
             echo ">> WARNING: Could not return to $ORIG_REF. You are on $current_head."
        fi
    fi
}

# Capture original ref for cleanup
if [[ "$MODE" != "plan" ]]; then
    ORIG_REF=$(git rev-parse --abbrev-ref HEAD 2>/dev/null || git rev-parse HEAD)
    # Restore original branch on exit/error
    trap cleanup EXIT
fi

# 1. Drift Detection
echo ">> Checking for drift..."
# Use porcelain v1 -z for robust parsing
if [[ -z "$(git status --porcelain=v1 -z)" ]]; then
  echo "No drift detected (working tree clean)."
  exit 0
fi

is_allowed() {
  local file="$1"
  local allowed=1 # 1=false (bash)

  # Explicit Allowlist Logic
  local patterns
  if [[ -n "$CUSTOM_ALLOW" ]]; then
      read -r -a patterns <<< "$CUSTOM_ALLOW"
  else
      read -r -a patterns <<< "$ALLOWLIST_DEFAULT"
  fi

  for p in "${patterns[@]}"; do
      if [[ "$file" == "$p"* ]]; then
          allowed=0
          break
      fi
  done

  # Artifacts logic
  if [[ "$INCLUDE_ARTIFACTS" == "1" ]] && [[ "$file" == "artifacts/"* ]]; then
      allowed=0
  fi

  return $allowed
}

is_secret() {
  local file="$1"
  # Hard Blocklist (Secrets) - Strict file matching
  # .env, .env.*, */.env, */.env.*
  if [[ "$file" == ".env" ]] || [[ "$file" == */.env ]] || \
     [[ "$file" == ".env."* ]] || [[ "$file" == */.env.* ]]; then return 0; fi

  # Extensions: *.key, *.pem, *.p12, *.pfx, *.kdbx, *.age
  if [[ "$file" == *".key" ]] || \
     [[ "$file" == *".pem" ]] || \
     [[ "$file" == *".p12" ]] || \
     [[ "$file" == *".pfx" ]] || \
     [[ "$file" == *".kdbx" ]] || \
     [[ "$file" == *".age" ]]; then return 0; fi

  # Specific names: id_rsa*, secrets.*
  if [[ "$file" == *"id_rsa"* ]] || [[ "$file" == *"secrets."* ]]; then return 0; fi

  return 1 # False
}

STAGED_FILES=()
IGNORED_FILES=()

# Process file list line by line (null-delimited)
while IFS= read -r -d '' entry; do
    # entry format: "XY PATH" or "XY PATH1" then "PATH2" (for renames)

    if [[ -z "$entry" ]]; then continue; fi

    status="${entry:0:2}"
    path="${entry:3}"

    # Handle rename/copy (R or C)
    # Status is typically "R " or "C "
    if [[ "$status" == R* ]] || [[ "$status" == C* ]]; then
        # Minimalist approach: Treat renames as-is (best effort).
        # We assume the next token is the new path, but without explicit parsing logic
        # to avoid fragility, we just read it to consume the token from the stream.
        # This means the 'path' variable (old path) is used for allowlist checks.
        # If the old path is allowed, it might stage the old path (deletion) but miss the new one?
        # WAIT. Git status -z output for R is: R  OLD\0NEW\0
        # If we read OLD into 'path', we MUST consume NEW or the next iteration will read NEW as status+path.

        IFS= read -r -d '' new_path
        # Use NEW path for logic (usually what we want to track)
        file="$new_path"
    else
        file="$path"
    fi

    if is_secret "$file"; then
        echo "CRITICAL ERROR: Secret-like file detected in drift: $file"
        echo "Aborting strictly to prevent leak."
        exit 2
    fi

    if is_allowed "$file"; then
        STAGED_FILES+=("$file")
    else
        IGNORED_FILES+=("$file")
    fi
done < <(git status --porcelain=v1 -z)

if [[ ${#STAGED_FILES[@]} -eq 0 ]]; then
    # Check if we only have artifacts drift
    only_artifacts=1
    for f in "${IGNORED_FILES[@]}"; do
        if [[ "$f" != "artifacts/"* ]]; then
            only_artifacts=0
            break
        fi
    done

    if [[ ${#IGNORED_FILES[@]} -gt 0 ]] && [[ "$only_artifacts" -eq 1 ]]; then
        echo "Only artifacts drift (ignored). Nothing to PR."
        exit 0
    fi

    echo "Drift detected but no files match the allowlist."
    echo "Ignored files:"
    printf ' - %s\n' "${IGNORED_FILES[@]}"
    exit 0
fi

echo ">> Staging Candidates (${#STAGED_FILES[@]} files):"
printf ' + %s\n' "${STAGED_FILES[@]}"

if [[ ${#IGNORED_FILES[@]} -gt 0 ]]; then
    echo ">> Ignored (${#IGNORED_FILES[@]} files):"
    printf ' . %s\n' "${IGNORED_FILES[@]}"
fi

# Plan Mode Exit
if [[ "$MODE" == "plan" ]]; then
    echo
    echo ">> Plan Mode (Dry Run):"
    echo "   Would create branch: ops/heimserver-drift-YYYYMMDD-HHMM"
    echo "   Would commit candidates."
    if [[ "$PUSH" == "1" ]]; then
        echo "   Would push to: $REMOTE"
    else
        echo "   Would NOT push (--no-push)."
    fi

    if [[ "$CREATE_PR" == "1" ]]; then
        echo "   Would create PR via 'gh pr create'"
    else
        echo "   Would NOT create PR (--no-pr or implicit)."
    fi
    exit 0
fi

# 3. Execution (Apply)
echo
echo ">> Executing..."

TIMESTAMP=$(date +"%Y%m%d-%H%M")
BRANCH_NAME="ops/heimserver-drift-$TIMESTAMP"
HOSTNAME=$(hostname -s)

if [[ -z "$PR_TITLE" ]]; then
    PR_TITLE="ops($HOSTNAME): sync local drift"
fi

# Base Branch detection
if [[ -z "$BASE_BRANCH" ]]; then
    if ! BASE_BRANCH=$(git remote show "$REMOTE" 2>/dev/null | grep 'HEAD branch' | cut -d' ' -f5); then
        echo "WARNING: Could not detect default branch from remote '$REMOTE'. Defaulting to 'main'."
        BASE_BRANCH="main"
    fi
fi

echo "   Base: $BASE_BRANCH"
echo "   Branch: $BRANCH_NAME"

# Create Branch
git checkout -b "$BRANCH_NAME"

# Stage Files
git add -A -- "${STAGED_FILES[@]}"

# Commit
BODY_TEMP=$(mktemp)
COMMIT_BODY="Sync drift from $HOSTNAME at $TIMESTAMP

Files:
$(printf ' - %s\n' "${STAGED_FILES[@]}")
"

# Construct final message: Title + Blank + Body
{
  echo "$PR_TITLE"
  echo ""
  echo "$COMMIT_BODY"
} > "$BODY_TEMP"

git commit -F "$BODY_TEMP"

if [[ "$PUSH" == "1" ]]; then
    echo ">> Pushing to $REMOTE..."
    git push -u "$REMOTE" "$BRANCH_NAME"

    if [[ "$CREATE_PR" == "1" ]]; then
        echo ">> Creating PR..."
        if command -v gh >/dev/null && gh auth status >/dev/null 2>&1; then
            PR_CMD=("gh" "pr" "create" "--base" "$BASE_BRANCH" "--title" "$PR_TITLE" "--body-file" "$BODY_TEMP")
            if [[ "$DRAFT_PR" == "1" ]]; then
                PR_CMD+=("--draft")
            fi
            "${PR_CMD[@]}"
        else
            echo "NOTE: 'gh' CLI not available or not authenticated."
            echo "To create PR manually, visit your repo or run:"
            echo "  gh pr create --base $BASE_BRANCH --head $BRANCH_NAME --title \"$PR_TITLE\" --body-file ..."
        fi
    else
        echo "PR creation skipped (--no-pr)."
    fi
else
    echo "Push skipped (--no-push). Changes are committed in branch '$BRANCH_NAME'."
fi

echo
echo "Done."
echo "To inspect the created branch: git checkout $BRANCH_NAME"
