#!/usr/bin/env bash
set -euo pipefail

# -----------------------------
# Weltgewebe Up (Deploy) Script
# -----------------------------
# Robust, idempotent, and optional-caddy-aware deployment wrapper.
#
# Usage:
#   weltgewebe-up [--with-caddy] [--no-pull] [--build-mode auto|force|no]

# REPO_DIR defaults are handled in resolution logic below
ENV_FILE="${ENV_FILE:-/opt/weltgewebe/.env}"
COMPOSE_PROJECT="${COMPOSE_PROJECT:-weltgewebe}"
REMOTE="${REMOTE:-origin}"
WELTGEWEBE_COMPOSE_BAKE="${WELTGEWEBE_COMPOSE_BAKE:-auto}"

# Base Compose File (always required)
BASE_COMPOSE_FILE="infra/compose/compose.prod.yml"
OVERRIDE_FILE="infra/compose/compose.prod.override.yml"

# Default Health URL (fallback)
HEALTH_URL_DEFAULT="http://127.0.0.1:8081/health/ready"

# Arguments
WITH_CADDY=0
DO_PULL=1
BUILD_MODE="auto"
PURGE_ZOMBIES=0
BUILD_WEB="auto"

usage() {
  echo "Usage: $0 [options]"
  echo
  echo "Options:"
  echo "  --with-caddy            Start the 'caddy' service (default: disabled/scale=0)"
  echo "  --no-pull               Skip git fetch/pull (offline deploy)"
  echo "  --build-mode MODE       Set build mode: auto (default), force, no"
  echo "  --no-build              Alias for --build-mode no"
  echo "  --force-build           Alias for --build-mode force"
  echo
  echo "Safety & Frontend:"
  echo "  --purge-compose-leaks   Automatically remove detected 'zombie' containers (from wrong project)"
  echo "  --build-web             Force frontend build"
  echo "  --no-build-web          Skip frontend build (warn only)"
  echo
  exit 1
}

while [[ "$#" -gt 0 ]]; do
  case $1 in
    --with-caddy) WITH_CADDY=1 ;;
    --no-pull) DO_PULL=0 ;;
    --build-mode)
       if [[ $# -lt 2 || -z "${2:-}" ]]; then
           echo "ERROR: --build-mode requires an argument (auto|force|no)."
           usage
       fi
       case "$2" in
           auto|force|no) BUILD_MODE="$2";;
           *)
               echo "ERROR: Invalid build-mode '$2'. Must be auto, force, or no."
               usage
               ;;
       esac
       shift
       ;;
    --no-build) BUILD_MODE="no" ;;
    --force-build) BUILD_MODE="force" ;;
    --purge-compose-leaks) PURGE_ZOMBIES=1 ;;
    --build-web) BUILD_WEB="force" ;;
    --no-build-web) BUILD_WEB="no" ;;
    -h|--help) usage ;;
    *) echo "Unknown parameter passed: $1"; usage ;;
  esac
  shift
done

# --- REPO_DIR Resolution ---
# We must find the actual repository root.
# Priority: ENV -> /opt -> Git Root -> Symlink -> CWD

FOUND_REPO=""

# 1. Environment Variable (Explicit - Strict)
if [[ -n "${REPO_DIR:-}" ]]; then
  if [[ -f "${REPO_DIR}/${BASE_COMPOSE_FILE}" ]]; then
     FOUND_REPO="$REPO_DIR"
  else
     echo "ERROR: REPO_DIR explicitly set to '$REPO_DIR' but config '$BASE_COMPOSE_FILE' not found." >&2
     echo "       Refusing fallback to prevent deploying from wrong location." >&2
     exit 1
  fi
else
  # Auto-Detection Logic

  # 2. Git Root (if inside a git repo - Strongest Context)
  if [[ -z "$FOUND_REPO" ]]; then
      if git rev-parse --show-toplevel >/dev/null 2>&1; then
          GIT_ROOT="$(git rev-parse --show-toplevel)"
          if [[ -f "${GIT_ROOT}/${BASE_COMPOSE_FILE}" ]]; then
              FOUND_REPO="$GIT_ROOT"
          fi
      fi
  fi

  # 3. Current Working Directory (Local Context)
  if [[ -z "$FOUND_REPO" ]]; then
      if [[ -f "./${BASE_COMPOSE_FILE}" ]]; then
          FOUND_REPO="$(pwd)"
      fi
  fi

  # 4. Symlink / Script Location Resolution (Physical Context)
  if [[ -z "$FOUND_REPO" ]]; then
      SCRIPT_SOURCE="${BASH_SOURCE[0]}"
      while [ -h "$SCRIPT_SOURCE" ]; do
        SCRIPT_DIR="$( cd -P "$( dirname "$SCRIPT_SOURCE" )" >/dev/null 2>&1 && pwd )"
        SCRIPT_SOURCE="$(readlink "$SCRIPT_SOURCE")"
        [[ $SCRIPT_SOURCE != /* ]] && SCRIPT_SOURCE="$SCRIPT_DIR/$SCRIPT_SOURCE"
      done
      SCRIPT_DIR="$( cd -P "$( dirname "$SCRIPT_SOURCE" )" >/dev/null 2>&1 && pwd )"
      # Assuming script is in scripts/weltgewebe-up, repo root is parent
      POTENTIAL_ROOT="$(dirname "$SCRIPT_DIR")"
      if [[ -f "${POTENTIAL_ROOT}/${BASE_COMPOSE_FILE}" ]]; then
          FOUND_REPO="$POTENTIAL_ROOT"
      fi
  fi

  # 5. Standard Path (/opt/weltgewebe - System Fallback)
  if [[ -z "$FOUND_REPO" ]]; then
      if [[ -f "/opt/weltgewebe/${BASE_COMPOSE_FILE}" ]]; then
          FOUND_REPO="/opt/weltgewebe"
      fi
  fi
fi

# Verification & Safety
if [[ -z "$FOUND_REPO" ]]; then
    echo "ERROR: Could not locate repository root containing $BASE_COMPOSE_FILE." >&2
    echo "       Please run from repo root, install to /opt/weltgewebe, or set REPO_DIR." >&2
    exit 1
fi

# Safety Guard: Prevent System Paths
# If the script is installed to /usr/local/bin and we fallback incorrectly, we might try to write to /usr/local/.ops
# Check both standard system paths and potentially dangerous ones
case "$FOUND_REPO" in
    /usr|/usr/*|/bin|/sbin|/etc|/var)
        echo "ERROR: Resolved REPO_DIR is system path: $FOUND_REPO" >&2
        echo "       This prevents accidental system modification." >&2
        echo "       Please set REPO_DIR explicitly to your repository path." >&2
        exit 1
        ;;
esac

REPO_DIR="$FOUND_REPO"
export REPO_DIR
cd "$REPO_DIR"

# Validation: Project Name
if [[ ! "$COMPOSE_PROJECT" =~ ^[a-z0-9_-]+$ ]]; then
  echo "ERROR: Invalid COMPOSE_PROJECT '$COMPOSE_PROJECT'. Must match [a-z0-9_-]."
  exit 1
fi
if [[ "$COMPOSE_PROJECT" == "compose" ]]; then
  echo "ERROR: COMPOSE_PROJECT cannot be 'compose'. This is the known drift signature."
  exit 1
fi

export COMPOSE_PROJECT_NAME="$COMPOSE_PROJECT"

# --- Bake Configuration ---
# If running in 'auto' mode and /apps is missing, we disable bake to prevent
# "resolve : lstat /apps: no such file or directory" errors in environments
# where the repository is sparse or modified (e.g. Heimserver production).

COMPOSE_BAKE_VALUE=""
# Allow overriding the probe path for testing/mocking
# We default to checking '/apps' because the failure mode "lstat /apps: no such file"
# specifically refers to the root path, not the repo path.
WELTGEWEBE_APPS_PROBE="${WELTGEWEBE_APPS_PROBE:-/apps}"

if [[ -z "${COMPOSE_BAKE:-}" ]]; then
    # Normalize input to lowercase for robust matching
    BAKE_MODE_NORMALIZED="${WELTGEWEBE_COMPOSE_BAKE,,}"

    case "$BAKE_MODE_NORMALIZED" in
        auto)
            # Heuristic: If the root /apps directory is missing, we assume a sparse/production environment
            # where buildx bake might fail due to missing context.
            if [[ ! -d "$WELTGEWEBE_APPS_PROBE" ]]; then
                COMPOSE_BAKE_VALUE="0"
                echo "NOTE: Apps directory '$WELTGEWEBE_APPS_PROBE' missing. Disabling COMPOSE_BAKE (auto)." >&2
            fi
            ;;
        0|false|off|no)
            COMPOSE_BAKE_VALUE="0"
            ;;
        1|true|on|yes)
            COMPOSE_BAKE_VALUE="1"
            ;;
        *)
            echo "WARNING: Unrecognized WELTGEWEBE_COMPOSE_BAKE value '$WELTGEWEBE_COMPOSE_BAKE' (expected: auto|0/1|true/false|on/off|yes/no). Ignoring." >&2
            ;;
    esac

    if [[ -n "$COMPOSE_BAKE_VALUE" ]]; then
        export COMPOSE_BAKE="$COMPOSE_BAKE_VALUE"
    fi
fi

# Guard: no foreign compose project using our config
# We specifically look for projects that are NOT ours but use our config files.
# AND/OR containers labeled explicitly as project 'compose'.
# Use grep -F to handle paths robustly.
ZOMBIES=$(docker ps --format '{{.Names}} {{.Label "com.docker.compose.project"}} {{.Label "com.docker.compose.project.config_files"}}' \
  | grep -F -- "$REPO_DIR/infra/compose" \
  | awk -v expected="$COMPOSE_PROJECT" '$2 != expected {print}' || true)

# Also explicitly catch generic "compose" project even if config path differs (e.g. via symlink or manual invocation)
# Use awk for exact field matching to avoid regex false positives.
ZOMBIES_GENERIC=$(docker ps --format '{{.Names}} {{.Label "com.docker.compose.project"}}' \
  | awk '$2 == "compose" {print}' || true)

if [[ -n "$ZOMBIES" || -n "$ZOMBIES_GENERIC" ]]; then
  ALL_ZOMBIES=$(echo -e "$ZOMBIES\n$ZOMBIES_GENERIC" | sort | uniq | grep .)

  if [[ -n "$ALL_ZOMBIES" ]]; then
    if [[ "$PURGE_ZOMBIES" == "1" ]]; then
       echo
       echo "WARNING: Detected zombie containers. Purging as requested..."
       # Extract container names (column 1)
       CONTAINERS=$(echo "$ALL_ZOMBIES" | awk '{print $1}')
       echo "Purging containers: $CONTAINERS"
       # shellcheck disable=SC2086
       docker rm -f $CONTAINERS
       echo "Purged."
    else
       echo
       echo "ERROR: Detected foreign compose project using weltgewebe config (or project 'compose')."
       echo "  Repo dir:              $REPO_DIR"
       echo "  Expected project name: $COMPOSE_PROJECT"
       echo
       echo "Offending containers (name project config_files):"
       echo "$ALL_ZOMBIES"
       echo
       echo "This causes port collisions and drift."
       echo "Resolve: identify foreign project (column 2), then run:"
       echo "  docker compose -p <foreign_project> down"
       echo "  (Or run with --purge-compose-leaks to auto-clean via 'docker rm -f')"
       echo
       exit 3
    fi
  fi
fi

# Ensure State Directory exists
# Default: .ops in REPO_DIR
WELTGEWEBE_STATE_DIR="${WELTGEWEBE_STATE_DIR:-$REPO_DIR/.ops}"
mkdir -p "${WELTGEWEBE_STATE_DIR}"
STATE_FILE="${WELTGEWEBE_STATE_DIR}/weltgewebe-up.state"

echo "== Weltgewebe Up =="
echo "Repo:    $(pwd)"
echo "Project: $COMPOSE_PROJECT"
echo "Env:     $ENV_FILE"

# 1. Environment Check
if [[ ! -f "$ENV_FILE" ]]; then
  echo
  echo "ERROR: ENV_FILE not found: $ENV_FILE"
  echo "Please create it (e.g. from .env.example) or set ENV_FILE=/path/to/.env"
  exit 2
fi

# Normalize ENV_FILE to absolute path
if [[ "$ENV_FILE" != /* ]]; then
  ENV_FILE="${REPO_DIR}/${ENV_FILE}"
fi

export WELTGEWEBE_ENV_FILE="${WELTGEWEBE_ENV_FILE:-$ENV_FILE}"

# 2. Git Operations (Prioritized if PULL enabled)
if [[ "$DO_PULL" == "1" ]]; then
  echo
  echo ">> Git Fetch..."

  if ! git fetch "$REMOTE" --prune; then
    echo "ERROR: Git fetch failed."
    echo "       Check network or use: $0 --no-pull"
    exit 1
  fi

  # Check for detached HEAD
  if ! BRANCH="$(git symbolic-ref -q --short HEAD)"; then
    echo "WARNING: Detached HEAD detected. Fetch done, but skipping pull."
    echo "         To update, checkout a branch (e.g. 'main')."
  else
    echo ">> Git Pull (fast-forward)..."
    if ! git pull --ff-only "$REMOTE" "$BRANCH"; then
        echo "ERROR: Git pull failed (fast-forward only)."
        echo "       Please resolve manually or use: $0 --no-pull"
        exit 1
    fi
  fi
else
  echo
  echo ">> Git: Skipped (--no-pull)"
fi

# 3. Preflight: Docker Compose Config (Strict)
# Run AFTER pull to validate new config
echo
echo ">> Preflight: Checking docker compose config..."
COMPOSE_FILES=("-f" "$BASE_COMPOSE_FILE")
if [[ -f "$OVERRIDE_FILE" ]]; then
  COMPOSE_FILES+=("-f" "$OVERRIDE_FILE")
else
  echo "NOTE: Override file '$OVERRIDE_FILE' not found. Using base compose only."
fi
BASE_ARGS=("--env-file" "$ENV_FILE" "-p" "$COMPOSE_PROJECT" "${COMPOSE_FILES[@]}")

if ! docker compose "${BASE_ARGS[@]}" config >/dev/null; then
  echo "ERROR: Docker Compose config failed. Please fix your configuration."
  exit 1
fi
echo "OK"

# 4. Build Decision
echo
echo ">> Build Decision:"

DO_BUILD=1
REASON="unknown"

# Get Current HEAD (safely)
if [[ "$DO_PULL" == "1" ]]; then
    CURRENT_HEAD=$(git rev-parse HEAD 2>/dev/null || echo "unknown")
else
    # Explicitly avoid git calls if no-pull
    CURRENT_HEAD="unknown"
fi

if [[ "$BUILD_MODE" == "force" ]]; then
    DO_BUILD=1
    REASON="Forced by --build-mode force"
elif [[ "$BUILD_MODE" == "no" ]]; then
    DO_BUILD=0
    REASON="Skipped by --build-mode no"
else
    # Auto Mode
    if [[ "$CURRENT_HEAD" == "unknown" ]]; then
        DO_BUILD=1
        REASON="Auto: HEAD unknown (conservative build)"
    elif [[ ! -f "$STATE_FILE" ]]; then
        DO_BUILD=1
        REASON="Auto: No previous deployment state found"
    else
        LAST_DEPLOYED_SHA=$(cat "$STATE_FILE")
        if [[ "$CURRENT_HEAD" != "$LAST_DEPLOYED_SHA" ]]; then
            DO_BUILD=1
            REASON="Auto: HEAD changed ($LAST_DEPLOYED_SHA -> $CURRENT_HEAD)"
        else
            DO_BUILD=0
            REASON="Auto: HEAD unchanged ($CURRENT_HEAD)"
        fi
    fi
fi

echo "   Mode:   $BUILD_MODE"
echo "   Reason: $REASON"
echo "   Action: $( [[ "$DO_BUILD" == "1" ]] && echo "Build" || echo "Skip Build" )"


# 5. Service Plan & Caddy Logic
HAS_CADDY=0
if docker compose "${BASE_ARGS[@]}" config --services | grep -qFx "caddy"; then
  HAS_CADDY=1
fi

SCALE_ARGS=()
ENABLE_CADDY=0

echo
echo ">> Service Plan:"
if [[ "$HAS_CADDY" == "1" ]]; then
  if [[ "$WITH_CADDY" == "1" ]]; then
    echo " - caddy: ENABLED (explicit request)"
    ENABLE_CADDY=1
  else
    echo " - caddy: DISABLED (default)"
    SCALE_ARGS=("--scale" "caddy=0")
  fi
else
  echo " - caddy: NOT FOUND"
  if [[ "$WITH_CADDY" == "1" ]]; then
     echo "WARNING: --with-caddy requested but service 'caddy' not found."
  fi
fi

# 6. Frontend Build (Optional/Heuristic)
if [[ -d "apps/web" ]]; then
  NEEDS_WEB_BUILD=0
  WEB_MSG="OK"

  if [[ "$BUILD_WEB" == "force" ]]; then
     NEEDS_WEB_BUILD=1
     WEB_MSG="Forced"
  elif [[ "$BUILD_WEB" == "no" ]]; then
     NEEDS_WEB_BUILD=0
     WEB_MSG="Skipped (explicit)"
  else
     # Auto
     if [[ ! -f "apps/web/build/index.html" ]]; then
        NEEDS_WEB_BUILD=1
        WEB_MSG="Auto: Artifact missing"
     fi
  fi

  if [[ "$NEEDS_WEB_BUILD" == "1" ]]; then
     echo
     echo ">> Frontend Build ($WEB_MSG)"

     if command -v pnpm >/dev/null; then
         # Check node_modules
         if [[ ! -d "apps/web/node_modules" ]]; then
             echo "   Installing dependencies..."
             pnpm -C apps/web install --frozen-lockfile
         fi
         echo "   Building..."
         pnpm -C apps/web build
     else
         echo "WARNING: Frontend build required but 'pnpm' not found."
         echo "         UI may be stale or broken."
         if [[ "$BUILD_WEB" == "force" ]]; then
             echo "ERROR: --build-web requested but pnpm missing."
             exit 1
         fi
     fi
  elif [[ "$BUILD_WEB" == "no" && ! -f "apps/web/build/index.html" ]]; then
      echo
      echo "WARNING: Frontend artifact missing and build disabled."
  fi
fi

# 7. Deploy
echo
echo ">> Deploying..."
CMD_BASE=("docker" "compose" "${BASE_ARGS[@]}" "up" "-d" "--remove-orphans")

if [[ "$DO_BUILD" == "1" ]]; then
    CMD_BASE+=("--build")
fi

if [[ "$ENABLE_CADDY" == "1" ]]; then
  # Try with Caddy enabled
  echo "Running: ${CMD_BASE[*]}"

  ERR_FILE=$(mktemp)
  if ! "${CMD_BASE[@]}" 2> "$ERR_FILE"; then
     ERR_CONTENT=$(cat "$ERR_FILE")
     rm -f "$ERR_FILE"

     # Check for bind errors (port conflict)
     if echo "$ERR_CONTENT" | grep -Eq "address already in use|port is already allocated|bind: address already in use"; then
        echo
        echo "WARNING: Port conflict detected (Caddy could not bind ports)."
        echo "Retrying without Caddy (--scale caddy=0)..."
        CMD_RETRY=("${CMD_BASE[@]}" "--scale" "caddy=0")
        echo "Running: ${CMD_RETRY[*]}"
        "${CMD_RETRY[@]}"
     else
        echo
        echo "ERROR: Deployment failed."
        echo "$ERR_CONTENT"
        exit 1
     fi
  else
     rm -f "$ERR_FILE"
  fi
else
  # Caddy disabled or not present
  CMD=("${CMD_BASE[@]}" "${SCALE_ARGS[@]}")
  echo "Running: ${CMD[*]}"
  "${CMD[@]}"
fi

# 7. Health Check
echo
echo ">> Status:"
docker compose "${BASE_ARGS[@]}" ps

echo
echo ">> Health Check:"

# Strategy Decision:
# 1. Explicit HEALTH_URL (override)
# 2. Host Port Mapping (if available)
# 3. Gateway (Explicit Only - e.g. 9081)
# 4. Docker Native Health (Default Fallback)

CHOSEN_STRATEGY="none"
HEALTH_CHECK_CMD=""

# Internal configuration defaults
API_INTERNAL_PORT="${API_INTERNAL_PORT:-8080}"
# Gateway Port Governance: 8081 is Pi-hole. Recommended is 9081.
WELTGEWEBE_GATEWAY_PORT="${WELTGEWEBE_GATEWAY_PORT:-}"

# Strategy 1: Explicit HEALTH_URL
if [[ -n "${HEALTH_URL:-}" ]]; then
  CHOSEN_STRATEGY="ENV:HEALTH_URL"
  echo "Using explicit health URL: $HEALTH_URL"
fi

# Strategy 2: Host Port Mapping
if [[ "$CHOSEN_STRATEGY" == "none" ]]; then
    API_PORT=""
    if RAW_PORT=$(docker compose "${BASE_ARGS[@]}" port api "${API_INTERNAL_PORT}" 2>/dev/null); then
        # Parse port. If output is "0.0.0.0:0", we get "0", which is invalid.
        PORT_CANDIDATE=$(echo "$RAW_PORT" | awk -F: '{print $NF}' | head -n1)
        if [[ "$PORT_CANDIDATE" != "0" && -n "$PORT_CANDIDATE" ]]; then
            API_PORT="$PORT_CANDIDATE"
        else
            echo "No published API port detected (port=0/empty)."
        fi
    fi

    if [[ -n "$API_PORT" ]]; then
        HEALTH_URL="http://127.0.0.1:${API_PORT}/health/ready"
        CHOSEN_STRATEGY="Host Port Mapping"
        echo "Using Host Port Mapping: $HEALTH_URL"
    fi
fi

# Strategy 3: Gateway (Explicit Only)
if [[ "$CHOSEN_STRATEGY" == "none" ]]; then
    if [[ -n "$WELTGEWEBE_GATEWAY_PORT" ]]; then
        if [[ "$WELTGEWEBE_GATEWAY_PORT" == "8081" ]]; then
            echo "WARNING: Port 8081 is usually reserved for Pi-hole. Recommended gateway port is 9081." >&2
        fi
        HEALTH_URL="http://127.0.0.1:${WELTGEWEBE_GATEWAY_PORT}/health/ready"
        CHOSEN_STRATEGY="Gateway (Explicit)"
        echo "Using Gateway Health (Explicit): $HEALTH_URL"
    fi
fi

# Strategy 4: Docker Native Health (Default)
if [[ "$CHOSEN_STRATEGY" == "none" ]]; then
    CHOSEN_STRATEGY="Docker Native Health"
    echo "Using Docker Native Health (inspect)"
fi

# Execution
echo "Health strategy selected: $CHOSEN_STRATEGY"

MAX_RETRIES=10
SLEEP_SEC=5
HEALTH_OK=0

check_health() {
    if [[ "$CHOSEN_STRATEGY" == "Docker Native Health" ]]; then
        API_CID=$(docker compose "${BASE_ARGS[@]}" ps -q api 2>/dev/null || true)
        if [[ -z "$API_CID" ]]; then
            echo "Container 'api' not found."
            return 1
        fi
        STATUS=$(docker inspect --format '{{.State.Health.Status}}' "$API_CID" 2>/dev/null || echo "unknown")
        if [[ "$STATUS" == "healthy" ]]; then
            return 0
        else
            echo "  Status: $STATUS"
            return 1
        fi
    else
        # Standard URL check from host
        if curl -fsS --connect-timeout 2 --max-time 5 "$HEALTH_URL" >/dev/null 2>&1; then
             return 0
        else
             return 1
        fi
    fi
}

for ((i=1;i<=MAX_RETRIES;i++)); do
  if check_health; then
    echo "Health OK ($CHOSEN_STRATEGY)"
    HEALTH_OK=1
    break
  fi
  echo "Waiting for health... ($i/$MAX_RETRIES)"
  sleep "$SLEEP_SEC"
done

if [[ "$HEALTH_OK" != "1" ]]; then
    echo "ERROR: Health check failed after $((MAX_RETRIES * SLEEP_SEC)) seconds."
    echo "Strategy: $CHOSEN_STRATEGY"
    [[ -n "${HEALTH_URL:-}" ]] && echo "URL: $HEALTH_URL"

    if [[ "$CHOSEN_STRATEGY" == "Docker Native Health" ]]; then
        echo "Docker Health Log (last 3 entries):"
        docker inspect --format '{{json .State.Health.Log}}' "$API_CID" 2>/dev/null | grep -o '{[^}]*}' | tail -n 3 || true
    fi

    echo "Tip: Check 'docker compose ps' and logs."
    exit 1
fi

echo
echo ">> Checking API DNS alias..."

# 1. Primary check: Inspect container metadata (Ground Truth)
# This works regardless of container OS (glibc/musl) or installed tools.
API_CID=$(docker compose "${BASE_ARGS[@]}" ps -q api 2>/dev/null || true)
if [[ -z "$API_CID" ]]; then
    echo "ERROR: Container 'api' not found."
    exit 1
fi

ALIAS_FOUND=0
if docker inspect --format '{{range .NetworkSettings.Networks}}{{println .Aliases}}{{end}}' "$API_CID" 2>/dev/null | grep -qw 'weltgewebe-api'; then
    ALIAS_FOUND=1
fi

if [[ "$ALIAS_FOUND" == "1" ]]; then
    echo "OK (via docker inspect)"

    # 2. Secondary check: Resolution inside container (Integration Test)
    # Only run if getent is available.
    if docker compose "${BASE_ARGS[@]}" exec -T api sh -c 'command -v getent >/dev/null 2>&1' >/dev/null 2>&1; then
        if docker compose "${BASE_ARGS[@]}" exec -T api getent hosts weltgewebe-api >/dev/null 2>&1; then
            echo "   (Resolution verified via getent)"
        else
            echo "WARNING: Alias configured, but 'getent hosts' failed inside container."
        fi
    fi
else
    echo "ERROR: DNS alias weltgewebe-api missing in container metadata."
    echo "       This violates the integration contract."
    echo "       Found aliases:"
    docker inspect --format '{{range .NetworkSettings.Networks}}{{println .NetworkID}} {{println .Aliases}}{{end}}' "$API_CID" 2>/dev/null || echo "       (docker inspect failed)"
    echo "Ensure 'aliases: [weltgewebe-api]' is set in compose."

    # Contract is strict. Fail unless explicitly opted out.
    if [[ "${ALLOW_UNSTABLE_API_DNS:-0}" == "1" ]]; then
        echo "WARNING: Continuing due to ALLOW_UNSTABLE_API_DNS=1."
    else
        exit 1
    fi
fi

# 8. Update State (Post-Health)
if [[ "$CURRENT_HEAD" != "unknown" ]]; then
    # Ensure directory exists just in case (e.g. if custom path changed during run)
    mkdir -p "$(dirname "$STATE_FILE")"
    echo "$CURRENT_HEAD" > "$STATE_FILE"
    echo ">> State updated: $CURRENT_HEAD"
fi

# 9. Snapshot
SNAPSHOT_SCRIPT="scripts/deploy-snapshot.sh"
if [[ -x "$SNAPSHOT_SCRIPT" ]]; then
  echo
  echo ">> Snapshot:"
  export COMPOSE_ARGS="${BASE_ARGS[*]}"
  export COMPOSE_FILE="$BASE_COMPOSE_FILE"
  export COMPOSE_PROJECT="$COMPOSE_PROJECT"
  export SNAPSHOT_MODE="live"

  bash "$SNAPSHOT_SCRIPT"
else
  echo "No executable snapshot script found at $SNAPSHOT_SCRIPT (skipping)"
fi

echo
echo "Done."
