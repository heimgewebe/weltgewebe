{
	order rate_limit before basicauth
}

:80 {
	# Health must be reachable without Host/TLS (local/CI checks use localhost:80)
	@health {
		path /health/ready
		method GET HEAD
	}
	handle @health {
		reverse_proxy api:8080
	}
	handle {
		respond 404
	}
}

weltgewebe.net {
	log {
		output stdout
		level INFO
	}

	encode zstd gzip

	rate_limit {
		zone login_limit {
			key {remote_host}
			events 5
			window 1m
		}
		zone login_consume_limit {
			key {remote_host}
			events 30
			window 1m
		}
		zone login_consume_get_limit {
			key {remote_host}
			events 60
			window 1m
		}
	}

	# Handle API requests (stripping the prefix implies using handle_path)
	handle_path /api/* {
		# Note: /api prefix is stripped here, so we match /auth/login/request directly
		@login_request {
			method POST
			path /auth/login/request
		}
		rate_limit @login_request login_limit

		@login_consume {
			method POST
			path /auth/login/consume
		}
		rate_limit @login_consume login_consume_limit

		# GET /auth/login/consume may be triggered by link scanners or prefetchers.
		# A relaxed rate limit prevents abuse without impacting normal login flows.
		@login_consume_get {
			method GET
			path /auth/login/consume
		}
		rate_limit @login_consume_get login_consume_get_limit

		reverse_proxy api:8080
	}

	# Explicitly forward health checks to the API
	handle /health/* {
		reverse_proxy api:8080
	}

	# Proxy internal health check
	handle /health/proxy {
		respond 200
	}

	# Proxy everything else to the configured web upstream (Cloudflare Pages or Vercel)
	reverse_proxy /* {env.WEB_UPSTREAM_URL} {
		header_up Host {env.WEB_UPSTREAM_HOST}
		header_up X-Forwarded-Proto {scheme}
		header_up X-Forwarded-Host {host}
		header_up X-Forwarded-For {remote_host}
	}

	header {
		# Security headers
		# CSP removed for v0 to avoid side-effects with external upstreams.
		# Should be tightened later when asset domains are stable.
		X-Frame-Options "DENY"
		Referrer-Policy "no-referrer"
		X-Content-Type-Options "nosniff"
	}
}
